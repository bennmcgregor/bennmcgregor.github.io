{"version":3,"sources":["webpack:///./src/pages/erging-classifier-upload.js"],"names":["CAPTURE_OPTIONS","video","RECORDING_OPTIONS","mimeType","LABEL_OPTIONS","BASELINE","BELOW_BASELINE","NO_LABEL","STATES","HOME","RECORDING","REVIEWING","LABELING","ErgingClassifierPage","useState","mediaStream","setMediaStream","mediaRecorder","setMediaRecorder","displayState","setDisplayState","db","setDB","recordedVideos","setRecordedVideos","currentVideoIndex","setCurrentVideoIndex","currentVidSrc","setCurrentVidSrc","timer","setTimer","fileRef","useRef","fileState","setFileState","label","isNext","a","id","transaction","clips","update","console","log","catch","err","error","newIndex","length","window","URL","revokeObjectURL","get","videoRecord","url","createObjectURL","data","useEffect","navigator","mediaDevices","getUserMedia","stream","getTracks","forEach","track","stop","enableStream","handleDataAvailable","event","size","blob","Blob","type","add","recorder","MediaRecorder","ondataavailable","initializeRecorder","database","Dexie","version","stores","open","stack","toCollection","count","zip","JSZip","sortedVideos","sort","record","filename","Date","now","toString","file","generateAsync","content","FileSaver","saveAs","clear","shuffle","array","temporaryValue","randomIndex","currentIndex","Math","floor","random","primaryKeys","videos","title","keywords-","className","ref","onSubmit","target","uploadFile","files","preventDefault","name","accept","required","multiple","styles","verticalLayout","vidSrc","onNextVideo","onPrevVideo","onReadyToLabel","currentClipNum","totalClips","labelOptions","onLabelSubmitted","onClick","interval","start","setInterval","clearInterval","disabled"],"mappings":"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","file":"component---src-pages-erging-classifier-upload-js-cc2bc94cbc58e14e6401.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react'\nimport Dexie from 'dexie'\nimport JSZip from 'jszip'\nimport FileSaver from 'file-saver'\n\nimport Layout from '../components/general/layout'\nimport SEO from '../components/general/seo'\nimport VideoDisplay from '../components/erging-classifier/video-display'\nimport LabelDisplay from '../components/erging-classifier/label-display'\nimport ReviewDisplay from '../components/erging-classifier/review-display'\nimport ErgingClassifierInfoDisplay from '../components/erging-classifier/info-display'\nimport styles from '../components/css/erging-classifier/erging-classifier.module.css'\n\nconst CAPTURE_OPTIONS = {\n  video: true,\n};\n\nconst RECORDING_OPTIONS = {\n  mimeType: \"video/webm; codecs=h264\",\n};\n\n// TODO: retrieve labels from remote server\nconst LABEL_OPTIONS = {\n  BASELINE: 'Baseline',\n  BELOW_BASELINE: 'Below Baseline',\n  NO_LABEL: 'No Label',\n}\n\nconst CLIP_LENGTH = 9000;\n\nexport const STATES = {\n  HOME: 'home',\n  RECORDING: 'recording',\n  REVIEWING: 'reviewing',\n  LABELING: 'labeling',\n};\n\nfunction ErgingClassifierPage() {\n  const [mediaStream, setMediaStream] = useState(null);\n  const [mediaRecorder, setMediaRecorder] = useState(null);\n  const [displayState, setDisplayState] = useState(STATES.HOME);\n  const [db, setDB] = useState(null);\n  const [recordedVideos, setRecordedVideos] = useState(null);\n  const [currentVideoIndex, setCurrentVideoIndex] = useState(0);\n  const [currentVidSrc, setCurrentVidSrc] = useState(null);\n  const [timer, setTimer] = useState(null);\n\n  const fileRef = useRef();\n  const [fileState, setFileState] = useState(null);\n\n  // video display\n  useEffect(() => {\n    async function enableStream() {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia(CAPTURE_OPTIONS);\n        setMediaStream(stream);\n      } catch(err) {\n        console.error(err);\n      }\n    }\n\n    if (!mediaStream) {\n      enableStream();\n    } else {\n      return function cleanup() {\n        mediaStream.getTracks().forEach(track => {\n          track.stop();\n        });\n      }\n    }\n  }, [mediaStream]);\n\n  // recording video\n  useEffect(() => {\n    function initializeRecorder() {\n      try {\n        const recorder = new MediaRecorder(mediaStream, RECORDING_OPTIONS);\n        recorder.ondataavailable = handleDataAvailable;\n        setMediaRecorder(recorder);\n      } catch(err) {\n        console.error(err);\n      }\n    }\n\n    function handleDataAvailable(event) {\n      if (event.data.size > 0 && db) {\n        var blob = new Blob([event.data], { type: \"video/mp4\" });\n        // save to the database\n        db.transaction('rw', db.clips, async () => {\n          const id = await db.clips.add({\n            data: blob,\n          });\n          console.log(`Wrote new video clip ${id} to the database`);\n        }).catch(err => console.error(\"Could not write new video clip to database\"));\n      }\n    }\n\n    if (mediaStream && !mediaRecorder) {\n      initializeRecorder();\n    }\n  });\n\n  // local database for video clips\n  useEffect(() => {\n    function initializeDB() {\n      const database = new Dexie(\"ClipDatabase\");\n      database.version(1).stores({ clips: \"++id,*label\" });\n      database.open().catch((err) => {\n        console.error(err.stack || err);\n      })\n      setDB(database);\n    }\n\n    if (!db) {\n      initializeDB();\n    }\n  });\n\n  // listen to page state change\n  useEffect(() => {\n    async function update() {\n      if (displayState === STATES.LABELING) {\n        if (recordedVideos.length > 0) {\n          const videoRecord = await db.clips.get(recordedVideos[currentVideoIndex]);\n          console.log(videoRecord);\n          const url = URL.createObjectURL(videoRecord.data);\n          setCurrentVidSrc(url);\n        }\n\n        // eventually: retrieve the label_options data from the server\n      } else if (displayState === STATES.HOME && recordedVideos) {\n        // if the database isn't empty, download all the files in the database\n        // with filename label-id.webm (eventually: send the data to a server)\n        const numRecords = await db.clips.toCollection().count();\n        if (numRecords > 0) {\n          const zip = new JSZip();\n          const sortedVideos = recordedVideos.sort();\n          for (const id of sortedVideos) {\n            const record = await db.clips.get(id);\n            let filename = \"\";\n            if (record.label !== 'NO_LABEL') {\n              filename = `${record.label}-`;\n            }\n            filename = filename + `${Date.now().toString()}.mp4`;\n            zip.file(filename, record.data);\n          }\n          const content = await zip.generateAsync({ type: \"blob\" });\n          FileSaver.saveAs(content, \"captured-rowing-data.zip\");\n          \n          // clear the database\n          db.clips.clear();\n          setRecordedVideos(null);\n        }\n        setCurrentVideoIndex(0);\n        setCurrentVidSrc(null);\n      }\n    }\n\n    update();\n  }, [displayState, db])\n\n  useEffect(() => {\n    function shuffle(array) {\n      var currentIndex = array.length, temporaryValue, randomIndex;\n    \n      // While there remain elements to shuffle...\n      while (0 !== currentIndex) {\n    \n        // Pick a remaining element...\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex -= 1;\n    \n        // And swap it with the current element.\n        temporaryValue = array[currentIndex];\n        array[currentIndex] = array[randomIndex];\n        array[randomIndex] = temporaryValue;\n      }\n    \n      return array;\n    }\n\n    async function update() {\n      if (displayState === STATES.REVIEWING) {\n        // TEMP\n        // load mp4s into db\n        db.clips.clear();\n\n        for (const file of fileState) {\n          var blob = new Blob([file], { type: \"video/mp4\" });\n          // save to the database\n          const result = await db.transaction('rw', db.clips, async () => {\n            const id = await db.clips.add({\n              data: blob,\n            });\n            console.log(`Wrote new video clip ${id} to the database`);\n          })//.catch(err => console.error(\"Could not write new video clip to database\"));\n        }\n\n        // initialize the new set of clips to iterate over for labeling\n        let videos = await db.clips.toCollection().primaryKeys();\n        videos = shuffle(videos);\n        setRecordedVideos(videos);\n        console.log(\"videos\", videos);\n\n        if (currentVidSrc) {\n          window.URL.revokeObjectURL(currentVidSrc);\n        }\n        if (videos.length > 0) {\n          const videoRecord = await db.clips.get(videos[currentVideoIndex]);\n          console.log(videoRecord);\n          const url = URL.createObjectURL(videoRecord.data);\n          setCurrentVidSrc(url);\n        }\n\n        /* initialize the new set of clips to iterate over for labeling\n        let videos = await db.clips.toCollection().primaryKeys();\n        videos = shuffle(videos);\n        setRecordedVideos(videos);\n        console.log(videos);\n\n        if (currentVidSrc) {\n          window.URL.revokeObjectURL(currentVidSrc);\n        }\n        if (videos.length > 0) {\n          const videoRecord = await db.clips.get(videos[currentVideoIndex]);\n          console.log(videoRecord);\n          const url = URL.createObjectURL(videoRecord.data);\n          setCurrentVidSrc(url);\n        }*/\n      }\n    }\n\n    update();\n  }, [displayState, db])\n\n  function toggleRecording() {\n    if (mediaRecorder) {\n      if (displayState === STATES.HOME) {\n        setDisplayState(STATES.RECORDING);\n        mediaRecorder.start();\n        initializeTimer();\n        // TODO: clean up current processes (if necessary)\n      } else if (displayState === STATES.RECORDING) {\n        mediaRecorder.stop();\n        clearInterval(timer);\n        setTimer(null);\n        setDisplayState(STATES.REVIEWING);\n      }\n    }\n  }\n\n  function initializeTimer() {\n    const interval = setInterval(() => {\n      mediaRecorder.stop();\n      mediaRecorder.start();\n    }, CLIP_LENGTH);\n    setTimer(interval);\n  }\n\n  async function onLabelSubmitted(label, isNext) {\n    // label the current video, move to the next one\n    const id = recordedVideos[currentVideoIndex];\n    db.transaction('rw', db.clips, async () => {\n      const updated = await db.clips.update(id, {\n        label\n      });\n      if (updated) {\n        console.log(`Labeled new video clip ${id} with label ${label}`);\n      }\n    }).catch(err => console.error(\"Error: Could not label the current video clip\"));\n    \n    let newIndex = currentVideoIndex;\n\n    if (isNext && currentVideoIndex === recordedVideos.length - 1) {\n      setDisplayState(STATES.HOME);\n      return;\n    } else if (isNext) {\n      newIndex += 1;\n    } else {\n      newIndex -= 1;\n    }\n\n    setCurrentVideoIndex(newIndex);\n\n    if (currentVidSrc) {\n      window.URL.revokeObjectURL(currentVidSrc);\n    }\n\n    // set video source\n    const videoRecord = await db.clips.get(recordedVideos[newIndex]);\n    const url = URL.createObjectURL(videoRecord.data);\n    setCurrentVidSrc(url);\n  }\n\n  async function onNextVideo() {\n    setCurrentVideoIndex(currentVideoIndex + 1);\n\n    if (currentVidSrc) {\n      window.URL.revokeObjectURL(currentVidSrc);\n    }\n\n    // set video source\n    const videoRecord = await db.clips.get(recordedVideos[currentVideoIndex + 1]);\n    const url = URL.createObjectURL(videoRecord.data);\n    setCurrentVidSrc(url);\n  }\n\n  async function onPrevVideo() {\n    setCurrentVideoIndex(currentVideoIndex - 1);\n\n    if (currentVidSrc) {\n      window.URL.revokeObjectURL(currentVidSrc);\n    }\n\n    // set video source\n    const videoRecord = await db.clips.get(recordedVideos[currentVideoIndex - 1]);\n    const url = URL.createObjectURL(videoRecord.data);\n    setCurrentVidSrc(url);\n  }\n\n  function onReadyToLabel() {\n    if (currentVidSrc) {\n      window.URL.revokeObjectURL(currentVidSrc);\n    }\n    setCurrentVidSrc(null);\n    setCurrentVideoIndex(0);\n    setDisplayState(STATES.LABELING);\n  }\n\n  function onFormSubmit(event) {\n    setFileState(event.target.uploadFile.files);\n    event.preventDefault();\n  }\n\n  useEffect(() => {\n    console.log(fileState)\n  }, [fileState]);\n\n  return (\n    <Layout>\n      <SEO title=\"Erging Classifier\" keywords-={['gatsby', 'application', 'react']}/>\n      <form className=\"upload\" ref={fileRef} onSubmit={onFormSubmit}>\n        <input type=\"file\" name=\"uploadFile\" accept=\".mp4\" required multiple />\n        <br/><br/>\n        <input type=\"submit\" />\n      </form>\n      <div className={styles.verticalLayout}>\n        <ErgingClassifierInfoDisplay />\n        <VideoDisplay mediaStream={mediaStream} vidSrc={currentVidSrc} displayState={displayState} />\n        { displayState === STATES.REVIEWING ?\n            <ReviewDisplay\n              onNextVideo={onNextVideo}\n              onPrevVideo={onPrevVideo}\n              onReadyToLabel={onReadyToLabel}\n              currentClipNum={currentVideoIndex ? currentVideoIndex + 1 : 1}\n              totalClips={recordedVideos ? recordedVideos.length : 0}\n            />\n          :\n            ( displayState === STATES.LABELING ?\n                <LabelDisplay\n                  labelOptions={LABEL_OPTIONS}\n                  onLabelSubmitted={onLabelSubmitted}\n                  currentClipNum={currentVideoIndex ? currentVideoIndex + 1 : 1}\n                  totalClips={recordedVideos ? recordedVideos.length : 0}\n                />\n              :\n                <button onClick={toggleRecording} disabled={!mediaRecorder}>\n                  {displayState === STATES.RECORDING ? 'STOP RECORDING' : 'START RECORDING'}\n                </button>\n            )\n        }\n      </div>\n    </Layout>\n  );\n}\n\nexport default ErgingClassifierPage;\n"],"sourceRoot":""}